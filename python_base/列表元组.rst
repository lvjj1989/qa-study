列表和元组
======================================
列表可以理解为一组数据，这组数据里可以包含不同的类型，可以往列表里增加数据，也可以删除，同时列表是可迭代的，也就是说可以用for循环去遍历。元组和列表基本一样，唯一不一样的是元组定义好之后就不能变了，不能增加也不能删除，下面我们介绍一下常见用法

定义一个列表
--------------------------------------

::

    l1 = []  # 定义一个空列表
    l2 = [1, 2, 3, 4, 5]  # 定义一个列表,里面包含同种类型的元素
    l3 = [1, 'a', None, 2.1, int]  # 定义一个列表,里面包含不同类型的元素


append:向列表未尾增加元素
--------------------------------------

::

    l1 = [1, 2, 3, 4, 5]
    l1.append(6)
    print(l1)

输出为::

    [1, 2, 3, 4, 5, 6]


insert:加入到索引为1的位置
-------------------------------------

::

    l1 = [1, 2, 3, 4, 5]
    l1.insert('10',1)
    print(l1)

输出为::

    [1,'10', 2, 3, 4, 5, 6]

pop:移除列表最后一个元素，并返回该元素
--------------------------------------

::

    l1 = [1, 2, 3, 4, 5]
    poped_element = l1.pop()
    print(poped_element)
    print(l1)

输出为::

    5
    [1, 2, 3, 4]

其他移除方法
--------------------------------------

::

    fruit = ['apple','pear','grape','orange']     
    fruit.remove('peach') #删除指定元素

    print(fruit) 

输出为::

    ['apple', 'pear', 'grape', 'orange']

::
    del fruit[2] #删除指定的索引
    print(fruit) 

输出为::

    ['apple', 'pear']


count:对其中的某个元素计数
--------------------------------------

::

    l1 = [1, 1, 2, 3, 4, 5]
    print(l1.count(1))

输出为::

    2

sort:排序
--------------------------------------

::

    l1 = [1, 5, 2, 3, 4, 0]
    l1.sort()
    print(l1)

输出为::

    [0, 1, 2, 3, 4, 5]

reverse:倒置列表
--------------------------------------

::

    l1 = ['a', 'b', 'c', 'd']
    l1.reverse()
    print(l1)

输出为::

    ['d', 'c', 'b', 'a']

index:查找其中某一个元素的位置
--------------------------------------
该方法有三个参数，index(v, i, j)，其中第一个为要查找的元素，第二个，第三个默认可以不用传，第二个参数是从第几个元素开始查找，第三个参数是查找到第几个元素结束::

    l1 = [1, 5, 2, 3, 4, 0, 1]
    print(l1.index(1))
    print(l1.index(1, 1))
    print(l1.index(1, 1, 5))

输出为::

    0
    6
    Traceback (most recent call last):
      File "/Users/sunhui/PycharmProjects/ps/a.py", line 7, in <module>
        print(l1.index(1, 1, 5))
    ValueError: 1 is not in list

extend:扩展列表
--------------------------------------
这个方法可以把一个列表拼接到另一个列表的后面::

    l1 = [1, 5, 2, 3, 4, 0, 1]
    l2 = ['a', 'b', 'c']
    l1.extend(l2)
    print(l1)

输出结果为::

    [1, 5, 2, 3, 4, 0, 1, 'a', 'b', 'c']

列表相加
--------------------------------------
两个列表直接相加可以返回拼接后的列表::

    l1 = [1, 2, 3]
    l2 = ['a', 'b', 'c']
    l3 = l1 + l2

    print(l3)

输出为::

    [1, 2, 3, 'a', 'b', 'c']


遍历列表
--------------------------------------
使用for循环可以遍历列表::

    l1 = [1, 2, 3, 4, 5]
    for i in l1:
        print(i)

输出为::

    1
    2
    3
    4
    5

列表去重
---------------------------------------------

::

    list1 = [1,2,3,4,2,1]
    list2 = list(set(list1))

输出为::

    [1, 2, 3, 4]


元组
--------------------------------------
因元组不能改，所以元组可以使用的方法比较少，常用的count和index，用法和列表是一样的::

    In [9]: t1.
                t1.count
                t1.index

还有一些别的用法，如

1. cmp(tuple1, tuple2) 比较两个元组元素  # python2。 
#. len(tuple) 计算元组元素个数。
#. max(tuple) 返回元组中元素最大值。
#. min(tuple) 返回元组中元素最小值。
#. tuple(seq) 将列表转换为元组。

在python3中，取消了cmp的用法，需要比较元素可以引用operator模块::

    >>> import operator
    >>> a = (1,2)
    >>> b = (1,3)
    >>> c = (1,2)
    >>> operator.eq(a, b)
    False
    >>> operator.eq(a, c)
    True
    >>>

切片
--------------------------------------
还是先看一下下面的这个图，需要好好理解一下::

    +---+---+---+---+---+---+
    | P | y | t | h | o | n |
    +---+---+---+---+---+---+
    0   1   2   3   4   5   6
    -6  -5  -4  -3  -2  -1

::

    l1 = ['p', 'y', 't', 'h', 'o', 'n']
    print(l1[0])  # p
    print(l1[5])  # n
    print(l1[-1])  # n
    print(l1[1:3])  # ['y', 't']
    print(l1[-3:-1])  # ['h', 'o']
    print(l1[3:])  # ['h', 'o', 'n']
    print(l1[:-3])  # ['p', 'y', 't']
    print(l1[::2])  # ['p', 't', 'o']

输出为::

    p
    n
    n
    ['y', 't']
    ['h', 'o']
    ['h', 'o', 'n']
    ['p', 'y', 't']
    ['p', 't', 'o']

练习
--------------------------------------
题1，把下面这个列表中的6取出来::


    l1 = [
        [1, 2, 3,
        [4, 5, 6]
        ]
    ]

题2，把下面这个列表中的每个元素+1::

    l = [1, 2, 3, 4, 5]

元组和列表的区别
-------------------------------------------

在python面试时，进程会被问到元组和列表的区别，大部分人只会回答：列表是可变的，元组是不可变的。这个回答显然过于简单了。我这边简单的整理了一下他们的区别，希望对大家有所帮助：

1. 列表是动态的，长度大小不固定，可以随意的增加、删减或者改变元素；而元组是静态的，长度大小固定，无法增加删减或者改变

#. 列表和元组的存储方式有差异::

    l = [1, 2, 3]
    l.__sizeof__()
    64
    tup = (1, 2, 3)
    tup.__sizeof__()
    48

列表和元组，放置了相同的元素，但是元组的存储空间，却比列表要少16字节。
事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于int型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。
但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。

#. 元组的性能略优于列表
列表和元组存储方式的差异，元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。
另外，Python 会在后台，对静态数据做一些资源缓存（resource caching）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。
但是对于一些静态变量，如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。
